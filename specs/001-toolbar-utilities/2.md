# Research: Toolbar Utilities Enhancements

**Branch**: 001-toolbar-utilities  
**Date**: 2025-12-07  
**Source Spec**: specs/001-toolbar-utilities/spec.md

## Decision 1: Toolbar & Windowing Framework
- **Decision**: Build the toolbar with WinForms ToolStrip hosted directly on the StatusForm so buttons inherit the always-on-top behavior and keyboard accessibility.
- **Rationale**: ToolStrip is native to the existing WinForms stack, supports shortcuts, icons, and docking without introducing new dependencies, and keeps focus behavior consistent with the tray window.
- **Alternatives Considered**:
  - Custom panel + button layout (more manual layout work, harder to ensure consistent styling/shortcuts).
  - Migrating the status window to WPF for richer controls (too large of a platform change and conflicts with single-file WinForms distribution).

## Decision 2: Settings Persistence & Validation
- **Decision**: Bind ppsettings.json into a dedicated SettingsViewModel, edit values via WinForms controls, validate using existing IOptions validators, and persist by emitting updated JSON back to disk followed by IOptionsMonitor refresh or targeted subsystem reload prompts.
- **Rationale**: Reusing the existing options contracts guarantees parity with runtime validation and keeps configuration stored in the same JSON file. Emitting JSON via System.Text.Json avoids manual string handling and keeps comments/ordering manageable.
- **Alternatives Considered**:
  - Directly editing the raw JSON text area (error prone, lacks context for nested sections).
  - Storing overrides in a new custom database (adds deployment complexity and diverges from AGENTS constraints).

## Decision 3: Relay Monitor Update Strategy
- **Decision**: Subscribe to MatchCoordinator.SnapshotUpdated and cache the latest successful relay payload (CombinedRelayPayload) so the Relay Monitor form simply renders a preformatted JSON tree that updates field-by-field without scrolling.
- **Rationale**: The coordinator already buffers both match and prop data; reusing its event stream guarantees the monitor stays aligned with the authoritative relay payload and avoids additional network polling.
- **Alternatives Considered**:
  - Polling log files or relay HTTP responses (laggy, duplicates existing buffering logic).
  - Streaming from the downstream relay endpoint (would require additional HTTP listener and expose sensitive data outside the app).

## Decision 4: Debug Payload Injection Path
- **Decision**: Route debug payload submissions through the existing IRelayService so authentication headers, logging, and error handling remain uniform. Inputs are validated via JSON schema before dispatch, and only one submission runs at a time with UI state indicating in-flight status.
- **Rationale**: Reusing the same relay code avoids duplicating HTTP logic, ensures bearer/CIDR policies remain in effect, and centralizes diagnostics.
- **Alternatives Considered**:
  - Creating a separate HTTP client specifically for debug submits (risk of drift in headers or retry policy).
  - Allowing arbitrary endpoints outside the configured relay (increases security risk and violates AGENTS binding rules).

## Decision 5: Preflight Match-Length Removal
- **Decision**: Remove the match-length check from the preflight UI and services while preserving team/player validations; the preflight panel instead notes that duration will display once the host transitions out of WaitingOnStart.
- **Rationale**: The host no longer sends match length before countdown, so keeping the check yields false failures. Informing the user without blocking keeps operations aligned with Constitution Principle III.
- **Alternatives Considered**:
  - Keeping the check but demoting it to a warning (still noisy and confusing when data is absent).
  - Trying to infer match length from historical config (inaccurate when host changes settings).
